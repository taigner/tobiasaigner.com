---
layout: post
title:  "Visualizing Recursion"
date:   2013-02-20
categories: programming
---

It seems that when the concept of recursion is introduced, a lot of people (including myself) have a hard time to understand it. Although, it is a powerful technique that is used in important algorithms. In addition, recursion often leads to simple and straightforward solutions.

I think one way of making things more clear is to visualize the process that is generated by a recursive algorithm.

## Fibonacci Numbers

The classical example for introducing recursion is [Fibonacci][fibonacci] numbers. Consider this implementation in Python:

{% highlight python %}
def fib(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
{% endhighlight %}

What is interesting about this algorithm is that it generates a process with a tree structure. This is illustrated in the following.

![Fibonacci Process](/images/fibonacci-process.png)

Just by looking at the source code it is hard to reason about its generated process. In contrast, I think the illustration helps.

The picture also shows why this naive implementation is quite slow. A large number of function calls are computed multiple times.

## Merge Sort

Another classical recursive algorithm is [Merge sort][mergesort]. It is a divide and conquer algorithm that recursively breaks the input down into smaller problems and merges it back in sorted order. The algorithm is implemented like this (full implementation is available [here][mergesortsrc]):

{% highlight python %}
def mergesort(lst):
    if len(lst) < 2:
        return lst
    middle = len(lst) / 2
    left = mergesort(lst[:middle])
    right = mergesort(lst[middle:])
    return merge(left, right)
{% endhighlight %}

The generated process of sorting 9, 1, 4, 6, 3, 2, 7, 8 is shown below.

![Merge Sort Process](/images/merge-sort-process.png)

## Constructing All Permutations

The problem of constructing all permutations of a string can be solved recursively. For instance, this implementation:

{% highlight python %}
def permutations(string, rest):
    if len(rest) == 0:
        return [string]

    result = []
    for i in xrange(len(rest)):
        next_rest = [rest[j] for j in xrange(len(rest)) if j != i]
        result.extend(permutations(string + rest[i], ''.join(next_rest)))
    return result
{% endhighlight %}

produces the following process for “abc”.

![Permutations Process](/images/permutations-process.png)

Moreover, the resulting permutations of “abc” reside at the leaves of the process tree: “abc”, “acb”, “bac”, “bca”, “cab” and “cba”.

## Conclusion

Of course, there are different strategies that help with understanding recursive processes. I think visualizing the process of a recursive algorithm is very helpful. Especially in the beginning.

## Further Reading

* [Structure and Interpretation of Computer Programs (especially Section 1.2)][sicp]
* [The Little Schemer][littleschemer]
* [The Algorithm Design Manual][algorithmdesign]


[fibonacci]:       https://en.wikipedia.org/wiki/Fibonacci_number
[mergesort]:       https://en.wikipedia.org/wiki/Mergesort
[mergesortsrc]:    https://en.literateprograms.org/Merge_sort_(Python)
[sicp]:            https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2
[littleschemer]:   https://www.amazon.com/gp/product/0262560992/
[algorithmdesign]: https://www.amazon.com/gp/product/1849967202/
